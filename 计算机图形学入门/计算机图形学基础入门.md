# 计算机图形学基础入门

**GAMES101**

**闫令琪**

## 2D图形的基本变换（2D Transformation）

### 图像的缩放(Scale)

<img src="..\计算机图形学入门\image\非均匀缩放.png" style="zoom:50%;" />
$$
\begin{aligned}
x^,&=s_xx \\
y^,&=s_yy\\
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
&=
\begin{bmatrix}
s_x & 0\\
0 & s_y\\
\end{bmatrix}
\begin{bmatrix}
z\\
y\\
\end{bmatrix}
\end{aligned}
$$

### 图像的对称(Reflection)

<img src="..\计算机图形学入门\image\对称.png" style="zoom:50%;" />
$$
\begin{aligned}
x^,&=-x \\
y^,&=y\\
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
&=
\begin{bmatrix}
-1 & 0\\
0 & 1\\
\end{bmatrix}
\begin{bmatrix}
z\\
y\\
\end{bmatrix}
\end{aligned}
$$

### 图像的切变(Shear)

<img src="..\计算机图形学入门\image\图形的切片.png" style="zoom:50%;" />
$$
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
=
\begin{bmatrix}
1 & a\\
0 & 1\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
$$

### 图像的旋转(默认沿原点逆时针,Rotation)

<img src="..\计算机图形学入门\image\图像的旋转.png" style="zoom:50%;" />
$$
R_\theta
=
\begin{bmatrix}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta\\
\end{bmatrix}
$$
<img src="..\计算机图形学入门\image\旋转矩阵的推导.png" style="zoom:50%;" />

### 线性变换矩阵归纳

**标准形式：**
$$
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
=
\begin{bmatrix}
a & b\\
c & d\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
$$
**缩放：**
$$
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
=
\begin{bmatrix}
s_x & 0\\
0 & s_y\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
$$
**切变：**
$$
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
=
\begin{bmatrix}
k & a/k\\
0 & k\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
$$
**旋转：**
$$
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
=
\begin{bmatrix}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
$$

### 移动(Transilation)与齐次坐标

<img src="..\计算机图形学入门\image\图像的移动.png" style="zoom:50%;" />
$$
\begin{bmatrix}
x^, \\
y^, \\
\end{bmatrix}
=
\begin{bmatrix}
a & b\\
c & d\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
+
\begin{bmatrix}
t_x\\
t_y\\
\end{bmatrix}
$$
**图像的移动无法用线性变换归纳！但是我们可以这样解决：**
$$
\begin{bmatrix}
x^, \\
y^, \\
\omega^,\\
\end{bmatrix}
=
\begin{bmatrix}
a & b & t_x \\
c & d & t_y \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
x+t_x\\
y+t_y\\
1\\
\end{bmatrix}
$$

$$
通常，我们知道：\\
\boxed{
1.矢量+矢量=矢量\\
2.点-点=矢量\\
3.点+矢量=点\\
4.点+点=？？
}\\
基于矩阵
\begin{bmatrix}
x\\
y\\
\omega\\
\end{bmatrix}在点相加后成为\begin{bmatrix}
x/\omega\\
y/\omega\\
1\\
\end{bmatrix}
(\omega\ne0)
$$

**所以点的相加得到的是两个点的终点！简单总结：**

**移动：**
$$
T_{s_x,s_y}
=
\begin{bmatrix}
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1 \\
\end{bmatrix}
$$
**缩放：**
$$
s_{(s_x,s_y)}
=
\begin{bmatrix}
s_x & 0 & 0 \\
0 & s_y & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
$$
**旋转：**
$$
s_{\alpha}
=
\begin{bmatrix}
\cos\alpha & -\sin\alpha & 0 \\
\sin\alpha & \cos\alpha & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
$$

### 认识逆变换

**对任意M的变换存在逆变换M^-1^，在数理意义上，逆变换相当于乘于逆矩阵。**

![](..\计算机图形学入门\image\逆变换.png)

### 变换的组合

<img src="..\计算机图形学入门\image\变换的组合.png" style="zoom:50%;" />

**想要完成上面的变换，我们需要将变换拆解**

<img src="..\计算机图形学入门\image\变换的组合1.png" style="zoom:50%;" />

**变换的顺序很重要！**

<img src="..\计算机图形学入门\image\变换的组合2.png" style="zoom:50%;" />

**看来变换的处理不满足交换律。**
$$
R_k·T_{(s_x,s_y)}\ne T_{(s_x,s_y)}·R_k
$$
**但是矩阵满足结合律：**
$$
W_1·(W_2·W_3)=(W_1·W_2)·W_3
$$


**而对于齐次坐标而言：**
$$
\begin{aligned}
T_{1,0}·R_{45°}\begin{bmatrix}x\\y\\1\end{bmatrix}
&=
\begin{bmatrix}
1 & 0 & 1 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
\cos k & -\sin k & 0 \\
\sin k & \cos k & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}x\\y\\1\end{bmatrix}\\
&=
\begin{bmatrix}
\cos k & -\sin k & 1 \\
\sin k & \cos k & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}x\\y\\1\end{bmatrix}\\
\end{aligned}
$$
**变换顺序为==先线性变换，再仿射变换==**。

## PS:特殊的旋转

**对于旋转矩阵，它的逆矩阵就是它的转置矩阵**
$$
R_{-\theta}=R_{\theta}^{-1}
$$
**对于这种矩阵，数学上称为正交矩阵**

## 三维图形变换

**简单推广二维情况就可以知道三维情况下：**
$$
\begin{aligned}
3D_{point} &=(x,y.z.1)^T\\
3D_{vector} &=(x,y.z.0)^T
\end{aligned}
$$
**进而推断存在三维齐次坐标：**
$$
\begin{bmatrix}
x^,\\y^,\\z^,\\1
\end{bmatrix}
=
\begin{bmatrix}
a & b & c & t_x \\
d & e & f & t_y \\
g & h & i & t_z \\
0 & 0 & 0 & 1\\
\end{bmatrix}
·
\begin{bmatrix}
x\\y\\z\\1
\end{bmatrix}
$$

### 对三维基本变换的归纳

**缩放：**
$$
S_{(s_x,s_y,s_z)}
=
\begin{bmatrix}
s_x & 0 & 0 & 0 \\
0 & s_y & 0 & 0 \\
0 & 0 & s_z & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$
**平移：**
$$
T_{(t_x,t_y,t_z)}
=
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$
**旋转(俯仰，侧滚，偏航)：**

![](..\计算机图形学入门\image\3D旋转.png)
$$
R_{x(\alpha)}=
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \cos \alpha & -\sin \alpha & 0 \\
0 & \sin \alpha & \cos \alpha & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

$$
R_{y(\alpha)}=
\begin{bmatrix}
\cos \alpha & 0 & \sin \alpha & 0 \\
0 & 1 & 0 & 0 \\
-\sin \alpha & 0 & \cos \alpha & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

$$
R_{z(\alpha)}=
\begin{bmatrix}
\cos \alpha & -\sin \alpha & 0 & 0 \\
\sin \alpha & \cos \alpha & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

### 罗德里格斯旋转分解公式（Rodrigues` Rotation Formula）

**分解沿过原点任意轴向旋转**
$$
R_{(n,\alpha)}=\cos(\alpha)I+(1-\cos(\alpha))nn^T+\sin(\alpha)\underbrace{
\begin{bmatrix}
0 & -n_z & n_y \\
n_z & 0 & -n_x \\
-n_z & n_x & 0 \\
\end{bmatrix}
}_{N}
$$

## 视图变换（View Transformation）

### 定义相机位置

<img src="..\计算机图形学入门\image\定义相机.png" style="zoom:67%;" />

**相机至少有一下属性：**

- 坐标位置(Position):$ \vec e$
- 视角朝向(Look-at / Gaze direction):$ \hat g$
- 上方向(UP direction):$ \hat t$



**相机变换？物体变换！**

- 只要相机和物体相对位置不变，变换就对成像无意义
- ==相机默认处于原点，向-z方向，以y方向为上方向==

![](..\计算机图形学入门\image\默认相机位.png)

### 相机变换

**存在相机处于坐标位置(Position):$ \vec e$，视角朝向(Look-at / Gaze direction):$ \hat g$，上方向(UP direction):$ \hat t$**

![](..\计算机图形学入门\image\假设相机.png)

**将其移动到默认位置需要：**

- 拆解变换$ M_{view}=R_{view}T_{view}$

- 移动$ \vec e$去往原点
  $$
  T_{view}=
  \begin{bmatrix}
  1 & 0 & 0 & -x_e \\
  0 & 1 & 0 & -y_e \\
  0 & 0 & 1 & -z_e \\
  0 & 0 & 0 & 1\\
  \end{bmatrix}
  $$

- 将$ \hat g$转向-z方向

$$
R_{z(\alpha)}=
\begin{bmatrix}
x_{\hat g \times \hat t} & y_{\hat g \times \hat t} & z_{\hat g \times \hat t} & 0 \\
x_t & y_t & z_t & 0 \\
x_{-g} & y_{-g} & z_{-g} & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

PS:可通过逆矩阵简单求得，因为旋转矩阵是正交矩阵，所以可以通过转置矩阵获得

$$
\boxed{
R_{view}^{-1}=

\begin{bmatrix}
x_{\hat g \times \hat t} & x_t & x_{-g} & 0 \\
y_{\hat g \times \hat t} & y_t & y_{-g} & 0 \\
z_{\hat g \times \hat t} & z_t & z_{-g} & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix} \
\stackrel{WHY?}{\Rightarrow } \
R_{z(\alpha)}=
\begin{bmatrix}
x_{\hat g \times \hat t} & y_{\hat g \times \hat t} & z_{\hat g \times \hat t} & 0 \\
x_t & y_t & z_t & 0 \\
x_{-g} & y_{-g} & z_{-g} & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
}
$$


- 将$ \hat t$转向y方向

### 正交投影变换（Orthographic Projection）

![](..\计算机图形学入门\image\正交投影.png)

**对于正交投影，远近关系只决定遮挡，而不会影响投影后的图像大小，为了进行这样的变换需要：**

- 建立立方体
  - 定义其左表面n，右表面b，上表面高度t，下表面高度r，前表面f，后表面n
  - 即[l,r]✖[b,t]✖[f,n]
  - 注意：因为是左手系，摄像机朝向-z，所以在数值上f<n,即远<近，在逻辑上和高大低小，右大左小很不一样

![](..\计算机图形学入门\image\建立立方体.png)

- 将这个立方体变换成为位于原点的[-1,1]✖[-1,1]✖[-1,1]标准立方体

  - 首先进行位移
  - 然后进行缩放

  

![](..\计算机图形学入门\image\变换成为标准立方体.png)
$$
W_{ortho}=
\begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & 0 \\
0 & \frac{2}{t-b} & 0 & 0 \\
0 & 0 & \frac{2}{n-f} & 0 \\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & -\frac{r+l}{2} \\
0 & 1 & 0 & -\frac{t+b}{2} \\
0 & 0 & 1 & -\frac{n+f}{2} \\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

### 透射投影（Perspective Projestion）

<img src="..\计算机图形学入门\image\透射投影.png" style="zoom: 80%;" />

**透射投影符合自然规律，近大远小，可以看成是对空间范围物体进行一次挤压，然后对结果正交投影：**

- 对视锥进行挤压

  - 挤压后图形x，y会通过图中相似三角形的方法变成和近点一样<img src="..\计算机图形学入门\image\透射挤压原理.png" style="zoom:80%;" />

  - 于是我们可以推出：


$$
\begin{bmatrix}
    x\\y\\z\\1
    \end{bmatrix}
    \Rightarrow
    \begin{bmatrix}
    nx/z\\ny/z\\Unknow\\1
    \end{bmatrix}
    \stackrel{mult.\\by \ z}{== }
    \begin{bmatrix}
    nx\\ny\\Still\ Unknow\\z
    \end{bmatrix}
$$

  - 于是我们可以得出变换前和变换后矩阵部分的情况


$$
    M_{persp\rightarrow otho}^{4\times 4}
    \begin{bmatrix}
    x\\y\\z\\1
    \end{bmatrix}
    =
    \begin{bmatrix}
    nx\\ny\\Still\ Unknow\\z
    \end{bmatrix}
$$

  - 推断出变换矩阵


$$
    M_{persp\rightarrow otho}^{4\times 4}=
    \begin{bmatrix}
    n & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 \\
    ? & ? & ? & ? \\
    0 & 0 & 1 & 0\\
    \end{bmatrix}
$$

  - 通过观察可知：

    - 任何近平面点不会发生任何变变化
    - 远平面的z也不会进行变化

  - 于是我们可以得出变换前和变换后矩阵的情况

    - 对于矩阵$ \begin{bmatrix}nx\\ny\\n^2\\1\end{bmatrix}$实质上和矩阵$ \begin{bmatrix}x\\y\\n\\1\end{bmatrix}$一样


$$
    M_{persp\rightarrow otho}^{4\times 4}
    \begin{bmatrix}
    x\\y\\z\\1
    \end{bmatrix}
    =
    \begin{bmatrix}
    nx\\ny\\Still\ Unknow\\z
    \end{bmatrix}
    \stackrel{replace\\z\ with\ n}{== }
    \begin{bmatrix}
    x\\y\\n\\1
    \end{bmatrix}
    \rightarrow
    \begin{bmatrix}
    x\\y\\n\\1
    \end{bmatrix}
    ==
    \begin{bmatrix}
    nx\\ny\\n^2\\n
    \end{bmatrix}
$$

  - 简化为：


$$
    \begin{bmatrix}
    0 & 0 & A & B
    \end{bmatrix}
    \begin{bmatrix}
    x\\y\\n\\1
    \end{bmatrix}
    =n^2
$$

  - 为了得出A，B我们来查看特殊情况：

    - 已知远平面的点z坐标依旧不变

    - 且远平面的中心点(0,0,f)的x，y坐标也不变化


$$
\begin{bmatrix}
      0\\0\\f\\1
      \end{bmatrix}
      \Rightarrow
      \begin{bmatrix}
      0\\0\\f\\1
      \end{bmatrix}
      ==
      \begin{bmatrix}
      x\\y\\f^2\\f
      \end{bmatrix}      
$$

- 得出方程式：

$$
      \begin{cases}
      An+B=n^2\\
      Af+B=f^2 \\
      \end{cases}
      \Rightarrow
      \begin{cases}
      A=n+f\\
      B=-nf\\
      \end{cases}
$$

  - 代入A，B就可以得到结果


$$
M_{persp\rightarrow otho}^{4\times 4}=\begin{bmatrix}n & 0 & 0 & 0 \\0 & 0 & 0 & 0 \\0 & 0 & n+f & -nf \\0 & 0 & 1 & 0\\\end{bmatrix}
$$

- 然后将变换完成的立方体进行正交投影

## 三角形的光栅化

### 定义视锥

![](..\计算机图形学入门\image\视锥的定义.png)

- **长宽比：**长度除宽度
- **垂直/平行可视角度：**锥底上与上方向相互垂直/平行的线在锥面上投影出的角度

**通过这些我们可以变换投影矩阵的相似三角形:**

![](..\计算机图形学入门\image\定义视锥对投影矩阵的影响.png)
$$
\tan{\frac {fovY}2}=\frac Y{|n|}
$$

$$
aspect=\frac rt
$$

### 什么是光栅化？

**现在我们拥有一个包含所有物体数据的([1,-1],[1,-1],[1,-1])立方体和一块被我们定义好的屏幕，屏幕上存在大量将会构成图像的像素，将图形转化为像素，这一步就是光栅化**

**对本课抽象概念的像素有以下定义：**

- 像素为平面正方形
- 像素有R，G，B三个属性，分别掌管一种颜色

**对本节课的屏幕空间有以下定义方案：**

![](..\计算机图形学入门\image\屏幕空间定义.png)

- 像素坐标都写为(x,y)形式，每个像素单位为1
  - Eg.蓝色像素坐标为(2,1)
- 所有像素存在于([0,width-1],[0,height-1])空间内
- 像素中心位于(x+0.5,y+0.5)范围内
- 屏幕空间位于([0,width],[0,height])范围内

### 如何光栅化？

- 视口变换（Ciewport Transformation）

  - 先不管z

  - 将立方体x，y变形为width，height

  - 立方体左下角变为屏幕左下角(0,0)

  - 变形方程为


    $$
    M_{viewport}=
    \begin{bmatrix}
    \frac{width}2 & 0 & 0 & \frac{width}2 \\
    0 & \frac{height}2 & 0 & \frac{height}2 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1\\
    \end{bmatrix}
    $$

- 三角形（Trianger）的优势

  - 三角形是最基础的多边形
  - 三角形必定是平面图形
  - 三角形的内外明确，不存在凹形挖孔情况
  - 可以利用重心坐标为三角形插值

### 采样式光栅化（Sampling）

**简单理解来说，采样就是对给定输入值求输出的过程，我们这里的采样指利用屏幕中心对图形采样**

<img src="..\计算机图形学入门\image\采样.png" style="zoom:50%;" />

**我们只需要判断屏幕中心是否位于某个三角形内即可,定义函数：**
$$
inside(t,x,y)\begin{cases}
1\ \ point(x,y)in \ triangle \ t\\
0\ \ otherwise\\
\end{cases}
$$

```c
for (int x=0 ; x<xmax ; ++x)
    for(int y=0 ; y<ymax ; ++y)
        image[x][y] = inside(tri
    					x+0.5,
                        y+0.5);
```

**那么如何实现inside()函数？**

<img src="..\计算机图形学入门\image\向量解决三角形包含问题.png" style="zoom:50%;" />

在上图里我们通过将Q与P~1~，P~2~相互叉乘的方法解决了判断Q位于P~1~，P~2~的哪一侧的问题，同样，我们只要将这个方法重复3次就可以判断Q是否被P~1~，P~2~，P~3~包围。

**如果点位于三角形边界上怎么办？**

<img src="..\计算机图形学入门\image\采样边界问题.png" style="zoom:50%;" />

**一般来说有两种解决方法：**

- 不做处理（忽略这一个像素）
- 特殊处理（两个三角形都是，或者是最后遍历的那个三角形，或者……）
- OpenGL和DX的解决方法是上边和左边算，下边和右边不算（较为复杂）

**显然，很多情况下，我们不需要遍历所有的屏幕空间来查看一个三角形，为三角形找一个包裹它的较小的矩形是一个不错的想法**

<img src="..\计算机图形学入门\image\优化遍历对象集.png" style="zoom:80%;" />

- 这个被大概选择的区域叫三角形的轴向包围和
- 获得这个区域只需要分别获得三个点中最小的x，最大的x，最小的y，最大的y即可

**有时候某些窄长倾斜的三角形会让包围和也难以解决，这个时候我们可以考虑仅遍历这个三角形范围内每行来解决问题**

<img src="..\计算机图形学入门\image\仅遍历三角形.png" style="zoom:80%;" />

## 反走样与深度缓冲

<img src="..\计算机图形学入门\image\走样.png" style="zoom:50%;" />

**现在我们有了这样的三角形，但显然这不是我们希望看到的，我们将这种因为采样量造成的扭曲称为瑕疵（Artifacts），大概有这些：**

- 边缘的走样（Jaggies）
- 条纹图案变成摩尔纹（Moire）
- 动画视频里的车轮效应
- 还有很多很多……

### 反走样？

**模糊图像后再栅格化是一种方法**

<img src="..\计算机图形学入门\image\0-1采样.png" style="zoom: 50%;" />

<img src="..\计算机图形学入门\image\模糊采样.png" style="zoom:50%;" />

### 频域（FrequencyDomain）

**正弦函数是一种常用的函数，其中的f表示频率**

![](计算机图形学入门/image/正弦函数.png)

**利用傅里叶级数展开我们可以将正弦函数拟近方波函数**

<img src="计算机图形学入门/image/傅里叶变换.png" style="zoom:50%;" />
$$
f(x)=\frac A2+\frac {2A\cos(tw)}{\pi}-\frac {2A\cos(3tw)}{3\pi}+\frac {2A\cos(5tw)}{5\pi}-\frac {2A\cos(7tw)}{7\pi}+...
$$
**同样的采样间隔可能对高频信号采样不足**

<img src="计算机图形学入门/image/走样的概念.png" style="zoom:80%;" />

**这种情况导致的信号失真就是走样**

<img src="计算机图形学入门/image/走样01.png" style="zoom:33%;" />

### 傅里叶变换（Fourier Transform）

**滤波：**将特定频率上的波段抹掉

**傅里叶函数：**可以将一个函数从时域变为频域，下图右侧为左侧的傅里叶函数变换

<img src="计算机图形学入门/image/傅里叶变换01.png" style="zoom:50%;" />

**高通滤波器：**去掉低频区域，只保留高频区域的滤波器，下图的右边就是去掉低频信号的结果，左边是用逆傅里叶变换得到的结果，可以看到结果多是边界

<img src="计算机图形学入门/image/高通滤波器.png" style="zoom:50%;" />

**低通滤波器：**只保留低频区域的滤波器，效果如下图

<img src="计算机图形学入门/image/低通滤波器.png" style="zoom:50%;" />

**卷积：**将一组数字的相邻每部分依次用数个权值运算相加，得到新的结果。这一组数字可以称为被卷积对象，数个权值被称为**卷积核**

<img src="计算机图形学入门/image/卷积.png" style="zoom: 50%;" />

**卷积也可以处理图像，可以看到很像低通滤波器的效果，简单来说，时域的卷积等于频域的乘积。九分之一的作用是防止图像亮度提升**

<img src="计算机图形学入门/image/卷积01.png" style="zoom:80%;" />

**所以我们可以将整个采样的过程看作被采样函数乘冲激函数得到一个采样结果，左图是这个过程，右图是其傅里叶变换的结果，也就是原傅里叶结果的卷积**

<img src="计算机图形学入门/image/傅里叶变换采样.png" style="zoom:80%;" />

**所以如果采样率不够，时域频谱就会重叠部分，也就产生了走样**

<img src="计算机图形学入门/image/走样的产生.png" style="zoom:67%;" />

### 如何进行反走样？

- 增加采样率

- 对图形进行卷积<img src="计算机图形学入门/image/低通滤波解决走样.png" style="zoom:50%;" />

  - 实际上我们会使用**MSAA**抗锯齿，对像素进行更加细致的划分，如何对划分进行采样，最后的结果平均到像素

    <img src="计算机图形学入门/image/超采样.png" style="zoom:48%;" />

    <img src="计算机图形学入门/image/超采样结果.png" style="zoom:50%;" />

### 深度缓存（Z-Buffer）

**画家算法：**先绘制最远的三角形，然后由远及近绘制，但是在下面的情况下几乎无法判断关系

<img src="计算机图形学入门/image/画家算法的局限.png" style="zoom:50%;" />

**深度缓存：**在采样同时按照像素产生深度图，遇到更接近摄像机的深度就更新，然后按照深度图来产生结果

![](计算机图形学入门/image/深度缓存.png)

```c++
for(each triangle T)
    for(each sample(x,y,z)in T)
        if(z<zbuffer[x,y])			//closest
            {
            framebuffer[x,y]=rgb;	//update color
			zbuffer[x,y]=z;			//update depth
        }
		else
            ;						//do nothing,this sample is occluded
```

<img src="计算机图形学入门/image/深度缓存01.png" style="zoom:80%;" />

## 着色（Shading）

对不同的物体运用不同的材质。

### 什么是B-P反射模型（Blinn-Phong Reflectance Model）

**高光（Specular highlight）：**朝向光源的区域出现的亮斑

**漫反射（Diffuse reflection）：**被光源散色区域产生的区域

**间接光照（Ambient lighting）：**被其他物体漫反射照射产生的区域

<img src="计算机图形学入门/image/PB材质.png" style="zoom:50%;" />

**着色是局部的！所以对一个点的着色不会使影像具有阴影。**

<img src="计算机图形学入门/image/着色是局部的.png" style="zoom:50%;" />

### B-P着色器的原理

- 实现漫反射效果

  - 漫反射是均匀分布的效果

    <img src="计算机图形学入门/image/B-P模型的漫反射.png" style="zoom:50%;" />

  - 漫反射的明暗与入射光角度有关

    <img src="计算机图形学入门/image/漫反射明暗与角度相关.png" style="zoom:50%;" />

  - 于是我们可以得到：

    <img src="计算机图形学入门/image/漫反射公式.png" style="zoom:80%;" />

- 实现高光相

  - 高光相是接近镜面反射的区域出现的效果

    ![](计算机图形学入门/image/高光公式.png)

  - p系数可以决定高光范围和效应方式

    <img src="计算机图形学入门/image/高光系数对高光的影响.png" style="zoom: 50%;" /><img src="计算机图形学入门/image/高光系数的实际效果.png" style="zoom:50%;" />

- 实现环境光效果

  - 环境光是周围环境的漫反射光照，但是在B-P模型下可以简单抽象为一个整数

    <img src="计算机图形学入门/image/环境光照.png" style="zoom: 80%;" />

- <img src="计算机图形学入门/image/P-B着色效果.png" style="zoom:80%;" />

### 着色频率（Shading Frequencies）

<img src="计算机图形学入门/image/着色频率.png" style="zoom:50%;" />

- 对面单一渲染，得到棱角化效果

  <img src="计算机图形学入门/image/Flat shading.png" style="zoom:67%;" />

- 对每一个顶点进行一次着色，得到较为平滑的效果

  <img src="计算机图形学入门/image/Gouraud shading.png" style="zoom:67%;" />

  - 那么如何实现顶点插值？插值的核心是利用三角形面积和法向修正着色的效果

    <img src="计算机图形学入门/image/插值解决着色频率.png" style="zoom:67%;" />

- 对每个像素进行着色，效果很好

  <img src="计算机图形学入门/image/Phong shading.png" style="zoom:67%;" />

  - 而逐像素插值就需要用到重心坐标

    <img src="计算机图形学入门/image/逐像素插值.png" style="zoom:50%;" />

### 实时渲染管线（Real-time Rendering Pipeline）

- 导入（Input）：将图形导入到3d空间并变换
- 投影（Vertices）：将三维空间的点投影到屏幕空间
- 三角形化顶点获得图形
- 光栅化（Fragments）：将三角化图形光栅化为Fragments
- 着色（shading）：将像素染色
- 输出（Output）

![](计算机图形学入门/image/渲染管线图解.png)

## 纹理映射（Texture Mapping）

**将3D图形剥离开平摊在2D平面上就是纹理映射**

<img src="计算机图形学入门/image/纹理映射-1618307223458.png" style="zoom:67%;" />

我们一般会将剥离得到的2D坐标铺在一个[0\~1,0~1]的**U-V坐标系**

<img src="计算机图形学入门/image/U-V-1618307348912.png" style="zoom:50%;" />

### 重心坐标

- 重心坐标配对唯一三角形

- 给定任意三角形平面内点给予唯一关于三角形顶点线性关系$ (\alpha,\beta,\gamma)$

  <img src="计算机图形学入门/image/重心坐标.png" style="zoom:80%;" />

- 尽管理论上定义了两个加上三角形内的条件就够了，但是定义是在三角形里面也需要三个数值。

- 我们同样可以利用面积分割计算重心坐标

  <img src="计算机图形学入门/image/面积分割求重心坐标.png" style="zoom:50%;" />

- 用下面的方法可以将（x，y）转换为$ (\alpha,\beta,\gamma)$

$$
\alpha=\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}\\
\beta=\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}\\
\gamma=1-\alpha-\beta
$$

- 利用重心坐标我们可以将几乎所有参数平滑插值在三角形上

  

<img src="计算机图形学入门/image/利用重心坐标插值.png" style="zoom:50%;" />

- 要注意的是重心坐标的三角形在投影到2D平面上后会变形，所以先在三维空间计算，然后投影

```c++
for each rasterized screen sample (x,y):
	(u,v)=evaluate texture coordinate at (x,y)
	texcolor=texture.sample(u,v);
	set sample`s color to texcolor;
```

### 线性插值（Bilinear interpolation）

利用双线性插值解决纹理贴图分辨率问题

<img src="计算机图形学入门/image/线性插值.png" style="zoom:50%;" />
$$
\begin{aligned}
&Linear \ interpolation(1D)\\
&lerp(x,v_0,v_1)=v_0+x(v_1-v_0)\\\\
&Two \ helper \ lerps\\
&u_0=lerp(s,u_{00},u_{10})\\
&u_1=lerp(s,u_{01},u_{11})\\\\
&Final \ vertucal \ lerp,ti \ get \ result\\
&f(x,y)=lerp(t,u_0,u_1)\end{aligned}
$$

### Mipmap

**如果纹理图片过大采样不足就会导致莫列纹和走样**

<img src="计算机图形学入门/image/采样不够导致纹理走样.png" style="zoom:50%;" />

**尽管增加采样可以解决问题，但是我们并不希望这样，因为采样增加意味性能需求增加**

我们推荐**Mipmap**

- 它只能应用于正方形查询
- 它并不准确
- 但是它很快！

<img src="计算机图形学入门/image/Mipmap.png" style="zoom: 50%;" />

<img src="计算机图形学入门/image/图像金字塔.png" style="zoom:50%;" />

**通过简单的级数求和可以知道图片增加这么多后容量只增加了1/3**

**通过查看UV上相邻的像素距离可以简单估算像素密度**

![](计算机图形学入门/image/估算像素密度.png)

**现在你可以求出这个面积在多少级的Mipmap上融合成为一个像素，然后对该级采样**

### 三线性插值（Trilinear interpolation）

**但是这样的突变采样行为显然可能在变级处形成割裂**

<img src="计算机图形学入门/image/突变Mipmap的局限.png" style="zoom:33%;" />

**为此我们要对Mip采样结果插值**

<img src="计算机图形学入门/image/Mipmap插值.png" style="zoom:67%;" />

**结果非常好**

<img src="计算机图形学入门/image/三线性插值.png" style="zoom:33%;" />

### 各向异性过滤

**Mipmap的局限：Overblur**

<img src="计算机图形学入门/image/Over blur.png" style="zoom: 50%;" />

**事实上我们并不是对每一个像素采样都是矩形范围，我们时不时可能需要不一样的比例压缩**

<img src="计算机图形学入门/image/各向异性01.png" style="zoom:50%;" />

<img src="计算机图形学入门/image/各向异性.png" style="zoom: 80%;" />

- **EWA过滤：**通过利用其他形状分割图形多次查询

  

<img src="计算机图形学入门/image/EWA过滤.png" style="zoom:50%;" />

### 阴影映射（Shadow Mapping）

- 阴影是同时出现在摄像机视野里而不出现在光源照射范围内的区域

<img src="计算机图形学基础入门.assets/ShadowMapping.png" style="zoom:50%;" />

- 我们可以对将光源的视野投射出Z-buffer
- 在对目标顶点着色的时候查看它相对于光源Z-buffer的mapping，远暗近亮，没有光就是Shadow

### 硬阴影（Hard Shadow）和软阴影（Soft Shadow）

<img src="计算机图形学基础入门.assets/硬阴影和软阴影.png" style="zoom: 50%;" />

- 对于硬阴影，光源是没有大小的，凡是没有照射到的地方都是阴影
- 对于软阴影，光源是有大小的，根据光照程度会有不同的阴影表现，部分被光源照射的区域会更亮

<img src="计算机图形学基础入门.assets/半影.png" style="zoom:50%;" />

## 几何（Geometry）

### 环境贴图（Environment Map）

**我们可以通过贴图的方式保存环境来达到反射的效果**

<img src="计算机图形学入门/image/环境贴图.png" style="zoom:50%;" />

**为了保存环境贴图我们可以将环境光保存在球面上，然后展开，但是这样容易损失极点附近信息**

<img src="image/埃舍尔自画像.png" style="zoom:50%;" /><img src="计算机图形学入门/image/圆柱投影环境贴图.png" style="zoom: 33%;" />

**我们也可以将球上的信息投影到立方体上展开，但是这样可能会增加计算量**

<img src="计算机图形学入门/image/立方体投影.png" style="zoom: 50%;" />

<img src="计算机图形学入门/image/立方体投影环境贴图.png" style="zoom:50%;" />

### 凹凸贴图

**纹理不光可以表现图形，我们还可以利用纹理修改高度**

<img src="计算机图形学入门/image/高度图.png" style="zoom:50%;" />

- 通过修改法线上的点对于法线扰动来产生复杂纹理 

<img src="计算机图形学入门/image/法线贴图.png" style="zoom:50%;" />

### 几何表述

- 隐式几何表述
  - 表述满足该结构的关系（表达式之类的），而非具象实例（点坐标之类的）
  - 不方便表示复杂的图形
  - 不容易识别表示图形
  - 方便判断是否位于物体内或者外
- 显式几何表述
  - 直接表达参与构成结构的所有实例（点，三角形之类的）
  - 通过参数映射方法将U-V平面实例到三维空间
  - 难以判断不同物体相对空间关系

### 融合（Blend）

<img src="计算机图形学入门\image\Blend.png" style="zoom: 50%;" />

**利用两个极态获取之间的状态，隐式表达几何**

![](计算机图形学入门\image\融合错误.png)

- A图表示初态，黑色遮挡面积为三分之一
- B图表示末态，黑色遮挡面积为三分之二
- 将二者简单平均，只能获得blend（A，B）的结果（遮挡，半遮挡，未遮挡），并不能表示实际中间态（遮挡二分之一）

![](计算机图形学入门\image\blendSDF.png)

- SDF（A）意为对A的有向距离函数，意为在此处相对边界的距离和方向（对于本例是遮挡区域还是未遮挡区域），SDF（B）同理
- 对SDF（A）和SDF（B）进行blend，函数结果的零点就会在我们期望的中线位置表现为零点

<img src="计算机图形学入门\image\blendEg.png" style="zoom:50%;" />

- 利用此我们可以融合不同的形状

![](计算机图形学入门\image\对融合结果获取空间边界.png)

- 我们并不是总能采样到正好为零的点，但是合理采样可以解决不少这样的问题，比如水平集（Level Set）就将距离丢到格子里

![](计算机图形学入门\image\3DLevelSet.png)

- 我们甚至可以定义三维水平集

### 显式几何表述方式

- **点云（Point Cloud）：**包含（x，y，z）的坐标列表

<img src="计算机图形学入门\image\PointCloud.png" style="zoom:50%;" />

- **多边形表示（Polygon Mesh）：**

  <img src="计算机图形学入门\image\三角形.png" style="zoom:50%;" />

  - **The Wavefront Object File（.obj）**文件格式

    ​	![](计算机图形学入门\image\obj文件内容.png)

    - v是指构成物体的所有点所在的坐标
    - vt是指构成该物体的所有纹理坐标
    - vn是指构成该物体的所有法线
    - f是对构成物体的三角形的定义，格式为：**f v1/v2/v3 vt1/vt2/vt3 vn1/vn2/vn3**

### 曲线（Curves）

- 贝塞尔曲线（Bézier Curves）

  ​	

  <img src="计算机图形学入门\image\贝塞尔曲线与控制点.png" style="zoom:50%;" />

  - 对上图定义了四个点

  - **de Casteljau Algorithm**算法被发明用于计算这些定义产生的曲线

    

    ![](计算机图形学入门\image\de Casteljau Algorithm求曲线算法.png)

    - 取$ b_0b_1$线段某点$ b_0^1$，取$ b_1b_2$线段某点$ b_1^1$，使得$ b_0b_0^1:b_1b_0^1=b_1b_1^1:b_2b_1^1$
    - 连接$ b_0^1b_1^1$
    - 取$ b_0^1b_1^1$某点$ b_2^0$，使得$ b_0^1b_0^2:b_1^1b_0^2=b_0b_0^1:b_1b_0^1=b_1b_1^1:b_2b_1^1$
    - 我们认为点$ b_2^0$存在曲线$ b_0b_2$上

    <img src="计算机图形学入门\image\贝塞尔曲线Eg.png" style="zoom: 67%;" />


    $$
    <Empty \space Math \space Block>
    $$

  - 为此我们可以定义贝塞尔曲线公式
    $$
    b_0^1(t)=(1-t)b_0-tb_1\\
    b_1^1(t)=(1-t)b_1-tb_2\\
    …
    $$
    **可以理解为当t为0时点$ b_1^1$无限趋近于$ b_0$，当t为1时点$ b_1^1$无限趋近于$ b_1$**

  - 归纳为**伯恩斯坦多项式（Bernstein polynomials）**

    

  <img src="计算机图形学入门\image\伯恩斯坦多项式.png" style="zoom: 50%;" />

  - 贝塞尔曲线的性质：

    - 必然经过起点和终点：$ b(0)=b_0;b(1)=b_1$

    - 在起点和终点曲线矢量方向为：$ b^`(0)=x(b_1-b_0);b^`(1)=x(b_3-b_2)$，x与控制点数量有关

    - 对控制点的**仿射变换**（线性变化加常数项）可以等比例变换该贝塞尔曲线；

      - 对投影变换不是如此

    - 贝塞尔曲线必然存在于定义它的控制点的凸包（Convex Hull）内

      - **凸包（Convex Hull）：**包围若干点的最小多边形

      <img src="计算机图形学入门\image\凸包.png" style="zoom:50%;" />

- 逐段贝塞尔曲线（Piecewise Bézier Curves）

  - 原版贝塞尔曲线不好控制，也不直观（如下图）

  

  <img src="计算机图形学入门\image\贝塞尔曲线的弊端.png" style="zoom:50%;" />

  - 于是我们有了Piecewise Cubic Bézier曲线

    

    

    <img src="计算机图形学入门\image\逐段贝塞尔曲线.png" style="zoom:50%;" />

    - 每四个控制点控制一段曲线（两个端点和两个贝塞尔曲柄）

    - 当相邻两端曲线段的始末曲柄沿着该点中心对称时这两段曲线会保持连续（参考贝塞尔曲线性质2）

      

    <img src="计算机图形学入门\image\逐段贝塞尔曲线示意图.png" style="zoom:50%;" />

- 样条（Spline）曲线

  - **定义：**由数个控制点构成的绝对平滑曲线
  - **B样条（B-Splines，Basis Splines）**
    - 具有**局部性**，指单一控制点对曲线的影响是被控制在局部的，脱离控制范围的曲线不会被该控制点影响
  - **非均匀游离B样条（NURBS）**

### 曲面（surface）

- 贝塞尔曲面（Bézier surface）

  

  <img src="计算机图形学入门\image\贝塞尔曲面.png" style="zoom:50%;" />

  - 这样定义一个4*4的贝塞尔曲面：

    - 先通过这些点得到四条在平行平面内的贝塞尔曲线

      

    <img src="计算机图形学入门\image\如何得到贝塞尔曲面1.png" style="zoom:50%;" />

    - 再用垂直这些平面的平面在四条线上截出四个点来定义横向贝塞尔曲线

      

    <img src="计算机图形学入门\image\如何得到贝塞尔曲面2.png" style="zoom:50%;" />

    - 重复采样用这些曲线构成曲面

      

    <img src="计算机图形学入门\image\如何得到贝塞尔曲面3.png" style="zoom:50%;" />

### 对Polygon Mesh的几何处理

- 表面细分（Mesh subdivision）
- 网格简化（Mesh simplification）
- 网格规整（Mesh regularization）

![](计算机图形学入门\image\对网格的处理.png)

### Monkey·D·Loop三角面细分（Loop Subdivision）

<img src="计算机图形学入门\image\细分.png" style="zoom:50%;" />

- 增加一定数量的Triangle

  

  <img src="计算机图形学入门\image\增加三角形.png" style="zoom:67%;" />

  - 取三角形每边终点，三角面数量*4

- 按照规则移动新旧顶点

  - 定义新点位置为$ P_{new}=\frac38(A+B)+\frac18(C+D)$

    <img src="计算机图形学入门\image\加权移动新点.png" style="zoom:67%;" />

  - 对于老的顶点更新我们需要：

    - 计算出该顶点的度n
    - 计算出u：$ \frac3{16}if\ n=3,\frac3{8n}otherwise$
    - 对点更新：$ (1-n*u)*original\_position+u*neighbor\_position\_sum$

### Catmull-Clark Subdivision多边形面细分(General Mesh)

- 定义：

  - **非四边面：**边数不为4的面
  - **奇异点（Extraordinary vertex）：**度不为4的顶点

  <img src="计算机图形学基础入门.assets/Catmull-Clark Subdivision.png" style="zoom:50%;" />

- 细分：对每个边和面分别取中点用线的中点连接面的中点

  <img src="计算机图形学基础入门.assets/4Subdivision.png" style="zoom: 33%;" />

  - 增加生了细分前非四边形面个奇异点
  - 所有的非四边形都消失了

- 可以预见再次细分也不会增加奇异点的数量

- 这种细分的位置更新需要分三种情况讨论

  - 位于面中点的
  - 位于边中点的
  - 旧有的顶点

  <img src="计算机图形学基础入门.assets/Catmull-Clark Vertex Update.png" style="zoom:67%;" />

![](计算机图形学基础入门.assets/How Subdivisions work like.png)

### Edge Coilops边坍缩（ Mesh Simplification减面）

![](计算机图形学基础入门.assets/边坍缩edge coilapsing.png)

**将面缩小为0，用点代替**

### 二次误差度量（Quadric Error Metrics）

![](计算机图形学基础入门.assets/二次误差度量Quadric Error Metrics.png)

- 左图可以发现将简化后的点简单的放在平均并不能表现出结构的实际情况
- 我们可以将简化后得到的点放在到原来构成的边的距离平方和最小处

<img src="计算机图形学基础入门.assets/二次误差调整坍缩.png" style="zoom: 50%;" />

- 我们可以通过二次度量误差确定坍缩的面，使其对模型影响更小

![](计算机图形学基础入门.assets/坍缩小奶牛.png)

## 光线追踪（Ray Tracing）

### 传统光栅化流程的缺陷

- 难以表现软阴影（Soft shadows）
- 难以处理二次反射（Glossy reflection）
- 难以处理间接光照（Indirect illumination）

<img src="计算机图形学基础入门.assets/光栅流程的短板.png" style="zoom:50%;" />

### 光线追踪基本原理

- “光线”（Light Ray）：
  - 光线沿直线传播。
  - 光线不会发生碰撞。
  - 光路可逆，==光从眼睛出发！==在经过一定反射和衰减后消失。

<img src="计算机图形学基础入门.assets/光线追踪基本原理.png" style="zoom:50%;" />

- 光线追踪基本：
  - 我从视点和像素连线打出一条“光线”
  - 光线到达一个顶点就将其与光源进行遮挡检定
  - 将结果返回像素 

### Whitted-Style Ray Tracing

<img src="计算机图形学基础入门.assets/Witted Style Ray Tracing.png" style="zoom:50%;" />

- 我们认为“光线”具有以下性质
  - 反射
  - 透射
  - 折射
  
- 这些性质会偏折分离光线，因此我们递归的求解光线每次反射，折射，和透射效果然后将光照结果按照光路“剩余能量”作为权值进行累加

### 简单求交点


- 定义数学上的光线：

    $$
    r(t)=o+td\ \ 0\leq t<\infty
    $$

    - **o:**光线起点
    - **t：**传播时间
    - **d：**行进方向

- 求光线与球的交点

    <img src="计算机图形学入门/image/光线与球的交点.png" style="zoom:50%;" />

    - 光线从光源出发行进的距离：
        $$
        r(t)=o+td\ \ 0\leq t<\infty
        $$

    - 球体的隐式表现：
        $$
        p:(p-c)^2-R^2=0
        $$

    - 光线从球心出发到达的距离：
        $$
        (o+td-c)^2-R=0
        $$

    - 联立求解得：
        $$
        t=\frac{-b\pm \sqrt{b^2-4ac}}{2a}
        $$
        <img src="计算机图形学入门/image/光线与球相交情况.png" style="zoom:50%;" />

- 推广到所有隐式表现

  - 光线从光源出发行进的距离：
    $$
    r(t)=o+td\ \ 0\leq t<\infty
    $$

  - 几何体的隐式表现：
    $$
    p:f(p)=0
    $$

  - 几何体光线方程：
    $$
    f(o+td)=0
    $$

- 三角形光线求交

  - 求交流程

    1. 光线和三角形所在平面的交点
    2. 交点是否在三角形内

  - 定义平面

    - 定义一个向量和一个点

    - 向量和平面垂直，点在平面内:
      $$
      p:(p-p^,)\cdot N=0\\
      \Rightarrow ax+by+cz+d=0
      $$

    - 带入几何体光线方程得：
      $$
      t=\frac{(p^,-o)\cdot N}{d\cdot N}\ Check:0\leq t < \infty
      $$

- MT算法快速求解（Möller Trumbore Algorithm）

  <img src="计算机图形学入门/image/Moller Trumbore法求解片元交点.png" style="zoom:50%;" />

  - $ \vec{O}+t\vec{D}$可以表示光线
  - $ (1-b_1-b_2)\vec{P_0}+b_1\vec{P_1}+b_2\vec{P_2}$可以表示重心坐标
  - 两者联立可以解出光线上任意一点的重心坐标
  - 即可判断光线是否打中片元

- 缺陷

  - 运算量巨大（求交次数=光线量*片元量）

### 包围盒（Bounding Volumes）

<img src="计算机图形学入门/image/包围和示意图.png" style="zoom:50%;" />

一个完全包围了该物体所有片元的简单物体，让未进入该包围区域的光线无需对该物体所有片元求交。

- 轴对齐包围盒（Axis-Aligned Bounding Box，AABB）

  - 一个由两个三维坐标定义的长方形

  - 在2D情况考虑

    <img src="计算机图形学入门/image/垂直空间包围盒2D算法求交.png" style="zoom:67%;" />

    - 对一条直线，将它在y轴产生的交点线段（左1）和它在x轴产生的交点线段（左2）进行交集就可以得出它与包围盒的交点线段。
    - **思路：**只有光线即进入了x轴交段，又进入了y轴交段光线才同时进入了两个交段，也就是包围盒

  - 延展到3D情况

    - 分别求三个平面的交线段
    - 求$ t_{enter}=max\{t_{min}\},t_{exit}=min\{t_{max}\}$得到结果
    - 如果$ t_{enter}<t_{exit}$,光线就与该盒相交

  - 特殊考虑

    - 当$ t_{exit}<0$，盒子在发射源的“后面”，没有交点
    - 当$ t_{exit}\geq0 \ and\ t_{enter}<0$,发射源在盒子里，有交点
    - **总结：**iff（当且仅当）$ t_{enter}<t_{exit}\ \&\&\ t_{exit}\geq 0$光线穿过AABB

  - 一般包围盒和AABB的区别

  <img src="计算机图形学入门/image/AABB和一般包围盒区别.png" style="zoom:67%;" />

### 包围盒网格（Grid Cell）

  - 现在在空间里我们有一些片元结构

    <img src="计算机图形学入门/image/包围网格.png" style="zoom:50%;" />

  - 我们将空间平铺上合适尺寸的网格（cell）

    <img src="计算机图形学入门/image/包围网格1.png" style="zoom:50%;" />

  - 网格里存在片元的部分被我们标记出

    <img src="计算机图形学入门/image/包围网格2.png" style="zoom:50%;" />

  - 对于光线我们只需要在通过存在片元的网格里对片元求交

    <img src="计算机图形学入门/image/包围网格3.png" style="zoom:50%;" />

  - 划分cell依据

    - 一般发现$ \#cells=C\times \#objs$在C约等于27时最好
    - “Teapot in a stadium（操场上的茶壶）”问题——本质是空的空间太大，导致过多的与空各自求交

### 空间划分（Spatial Partit）

<img src="计算机图形学入门/image/空间划分算法.png" style="zoom:80%;" />

- 八叉树（Oct-Tree）
  - 对空间进行2\*2\*2均匀划分直到到达限制
  - **限制举例：**cell到达预设大小或者cell内不再有片元
- **KD-Tree**
  - 每次将空间按照规则与坐标轴对其地一分为二，直到达到限制
  
    <img src="计算机图形学入门/image/KD-Tree.png" style="zoom: 50%;" />
  
    <img src="计算机图形学入门/image/递归KD-Tree.png" style="zoom: 50%;" />
- BSP-Tree
  - 每次将空间按照规则一分为二，产生空间非AABB，直到达到限制



### 物体划分（Bounding Volume Hierarchy，BVH）

- BVH的建立

  - 对每个物体建立Root节点

    <img src="计算机图形学入门/image/BVH0.png" style="zoom:50%;" />

  - 在节点下对片元进行划分，为划分的区域建立AABB

    <img src="计算机图形学入门/image/BVH.png" style="zoom:50%;" />

  - 就这样一直划分直到达到限制，同一个片元不会存在多个AABB内，但是不同AABB之间可以重叠

    <img src="计算机图形学入门/image/BVH1.png" style="zoom:50%;" />

- BVH的递归

  <img src="计算机图形学入门/image/BVH的递归.png" style="zoom:67%;" />

## 基础辐射度量学（Basic radiometry）

- **动机：**我们之前的所有渲染体系的辐射参数，包括衰减，反射等等都是没有任何度量理论支持的，这导致我们的光照算法再精确也无法表达正确的图像
- **内容简介：**描述光照的方法与单位，但完全基于几何光学。
  - 全新的物理量：**Radiant flux**，**intensity**，**irradiance**，**radiance**

### Radiant Energy and Flux（Power）

- **Energy**

  - 能量单位是J（焦耳）
    $$
    Q[J=Joule]
    $$

- **Flux（Power）**

  - Flux（Power）是单位时间的能量，所以单位是W（瓦特）和lm（流明）
    $$
    \Phi \equiv \frac{dQ}{dt}[W=Watt][lm=lumen]^*
    $$

  - 也可以固定单位时间，然后计算通过某区域的所有能量来定义Flux

    <img src="计算机图形学入门/image/Flux.png" style="zoom: 50%;" />

- 我们想要定义的辐射

  <img src="计算机图形学入门/image/我们感兴趣的辐射话题.png" style="zoom: 50%;" />

  - 光源发出的辐射:**Radiant Intensity**
  - 物体接收的辐射:**Irradiance**
  - 传播光线的辐射:**Radiance**

### Radiant Intensity

- **定义：**power per unit solid angle
  $$
  I(w)\equiv \frac{d\phi}{dw}
  $$

- **单位：**power单位除以空间角单位，就是cd（坎德拉）
  $$
   \left[\frac{W}{sr}\right]\left[\frac{lm}{sr}=cd=candela\right]
  $$

- **立体角（solid angle）**定义

  <img src="计算机图形学入门/image/Solid angle.png" style="zoom:67%;" />

- 对**立体角（solid angle）**微分的定义

  <img src="计算机图形学入门/image/单位立体角.png" style="zoom: 67%;" />
  $$
  \begin{aligned}
  dA&=(r\ d\theta)(r\ \sin{\theta}\ d\phi)\\
  &=r^2sin{\theta}\ d\theta\ d\phi\\
  dw&=\frac{dA}{r^2}=\sin{\theta}\ d\theta\ d\phi
  \end{aligned}
  $$

  - 对所有微分立体角求积分可以得到球$ S^2$
    $$
    \begin{aligned}
    \Omega &= \int_{S^2}dw\\
    &=\int_{0}^{2\pi}\int_{0}^{\pi}\sin{\theta}\ d\theta\ d\phi\\
    &=4\pi
    \end{aligned}
    $$

- Eg.现在有一个815lumens的灯，求其Radiant Intensity

  - Intensity=815lumens/4pi sr=65candelas

### Irradiance

- **定义：**power per unit area
  $$
  E(x)\equiv\frac{d\Phi(x)}{dA}
  $$

- **单位：**power单位除以面积的单位，也就是lux(勒克斯)
  $$
  \left[\frac W{m^2}\right]\left[\frac {lm}{m^2}=lux\right]
  $$
  
- 辐照面积必须是垂直光线辐照方向面积的投影

  <img src="计算机图形学入门/image/辐照面积.png" style="zoom:67%;" />

### Radiance

- **动机：**讨论光线在传播过程里的某些特性

- **定义：**power per unit solid angle,per project unit area

  <img src="计算机图形学入门/image/Radiance.png" style="zoom:50%;" />
  $$
  L(p,w)\equiv\frac{d^2\Phi(p,w)}{dw\ dA\cos{\theta}}
  $$

- **单位：**power单位除以立体角和面积单位，也就是nit
  $$
  \left[\frac{W}{sr\ m^2}\right]\left[\frac{cd}{m^2}
  =\frac{lm}{sr m^2}=nit\right]
  $$

- 换个角度，我们也可以吧Radiance看成：

  - **Radiance：**Irradiance per solid angle
  - **Radiance：**Intensity per projected unit area

### 双向反射分布函数(Bidirectional Reflectance Distribution Function,BRDF)

<img src="计算机图形学入门/image/BRDF.png" style="zoom:67%;" />

- **定义：**BRDF 描述的是任意一个出射角占入射角总能量的比例
  $$
  f_r(w_i\rightarrow w_r)=\frac{dL_r(w_r)}{dE_i(w_i)}\\
  =\frac{dL_r(w_r)}{L_i(w_i)\cos{\theta_i}\ dw_i}\left[\frac{1}{sr}\right]
  $$

- **用途：**更加全面的定义表面反射材质（材质表面单位面积反射的光是由涉及该区域的所有Radiance决定的）

  <img src="计算机图形学入门/image/BRDF定义材质.png" style="zoom:50%;" />
  $$
  L_r(p,w_r)=\int_{H^2}f_r(p,w_i\rightarrow w_r)L_i(p,w_i)\cos(\theta_i)\cos{\theta_i}dw_i
  $$
  

### 渲染方程（Rendering Equation）

BRDF忽略了一件事情，那就是如果单位面积的材质会发光怎么办。在渲染方程里我们将它加入：
$$
\boxed{
L_r(p,w_0)=L_e(p,w_o)+\int_{\Omega^+}L_i(p,w_i)f_r(p,w_i, w_o)L_i(n,w_i)dw_i
}
$$
**PS:**H^2^或者Ω^+^都是半球的意思

## 【特别篇】简单概率论回顾

- **随机变量X：**一个取值不一定的变量
- **随机变量分布X ~ p(x)：**随机变量在分布范围里的分布状态
- 随机变量在分布求积分为1
- **期望E[X]：**用概率作为加权累加所有取值
- **连续概率的概率密度函数p(x)：**随机变量函数在分布范围里的分布密度
- **连续概率的期望E[X]：**$ E[X]=\int xp(x)dx$
